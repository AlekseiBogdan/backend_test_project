# Test task for backend developer position

## First task (file ```fibonacci.py```)

> Each new term in the Fibonacci sequence is generated by adding the previous two terms. 
> By starting with 3 and 4, the first 10 terms of the Finonacci-like sequence will be: 3, 4, 7, 11, 18, 29, 47, 76, 123, 199, ... .
> By considering the terms in this sequence whose values do not exceed seven million, find the sum of the even-valued terms.

The only difference with usual fibonacci sequence is starting point being 3 and 4 instead of 0 and 1.

I decided to use simple recursive function to calculate the sequence.

```python
from functools import cache

@cache
def fibonacci_of(n: int):
    if n in [3, 4]:
        return n
    return fibonacci_of(n - 1) + fibonacci_of(n - 2)
```

Time complexity on that function is exponential, so I used `@cache` from `functools`. 

This way I reduced time complexity to O(n), as cache approach is _kind of_ similar to the solution with simple list-checking for already existing values.


```fib_sum()``` is the main function that calls the recursive calculation.

We call the calculation and append it to the list until the result is bigger that ```7,000,000```, then calculate the sum of even elements with the generator. 
```python
def fib_sum():
    fib_list = [3, 4]
    f = 3
    while f:
        numb = fibonacci_of(f)
        if numb > 7000000:
            break
        if numb not in fib_list:
            fib_list.append(numb)
        f += 1
    even_fib_sum = sum(n for n in fib_list if not n % 2)
    print(even_fib_sum)
    return even_fib_sum
```

I calculated time of execution and got something around ~0.01 seconds with using the cache trick. Calculating without it (так сказать, __на холодную__), takes around 5 seconds.

## Second task (file ```main.py```)

>Create an echo server that receives string messages and sends them back in the upper case. Server must support many simultaneous connections.

I decided to use FastAPI because 
- I actually just wanted to try it 
- it offers ```starlette``` websockets implementation straight out of the box

I assume that phrase should be received by the server from the URL, so I created small JS-script to get and send the phrase.

```javascript
const ws = new WebSocket("ws://localhost:8000/ws/{phrase}");
            
const phrase = window.location.href.split('/').slice(-1);
            
ws.addEventListener("open", (event) => {
                ws.send(phrase);
    });
```

Also I create websocket connection with my server, _kind of_ connecting my front- and backend.

This script is placed inside of the HTML.

To handle multiple connections I introduced ```ConnectionManager``` class:

```python
class ConnectionManager:
    def __init__(self):
        self.active_connections: list[WebSocket] = []

    async def connect(self, websocket: WebSocket):
        await websocket.accept()
        self.active_connections.append(websocket)

    def disconnect(self, websocket: WebSocket):
        self.active_connections.remove(websocket)

    async def send_personal_message(self, message: str, websocket: WebSocket):
        await websocket.send_text(message)
```
After client connects to websocket connection it is being appended to the list, so we get easy access to all established connections.
When message is processed we remove connection from the list and then close the connection. I wrapped everything in useful abstraction just to be able to handle many simultaneous connections.



When phrase is sent to server over websocket connection it is being translated to uppercase, then sent back (after that websocket connection is closed).

```python
@app.websocket("/ws/{phrase}")
async def websocket_endpoint(websocket: WebSocket):
    await manager.connect(websocket)
    data = await websocket.receive_text()
    await manager.send_personal_message(data.upper(), websocket)
    manager.disconnect(websocket)
    await websocket.close()
```

Then page receives the message, places it inside the ```<h1>``` tag inside the ```<div>```

```javascript
ws.addEventListener("message", (event) => {
                const resp = document.createElement('h1');
                resp.appendChild(document.createTextNode(event.data));
                document.getElementsByTagName("div")[0].appendChild(resp);
            });
```

## requirements.txt

Written just in case, consists only of ```fastapi```, I consider we use Python >= 3.10 (also because of the ```@cache``` in the ```fibonacci.py```, as in previous Python versions it was ```@lru_cache```).

























